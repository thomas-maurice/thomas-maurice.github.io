<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>/var/log/tmaurice</title>
    <link>https://blog.thomas.maurice.fr/</link>
    <description>Recent content on /var/log/tmaurice</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>thomas@maurice.fr (Thomas)</managingEditor>
    <webMaster>thomas@maurice.fr (Thomas)</webMaster>
    <copyright>&amp;copy;{year}, All Rights Reserved</copyright>
    <lastBuildDate>Sat, 29 Aug 2020 11:02:50 +0000</lastBuildDate>
    
        <atom:link href="https://blog.thomas.maurice.fr/index.xml" rel="self" type="application/rss+xml" />
    
      
      
      

      
      <item>
        <title>Network namespaces in Linux</title>
        <link>https://blog.thomas.maurice.fr/posts/network-namespaces-in-linux/</link>
        <pubDate>Sat, 29 Aug 2020 11:02:50 +0000</pubDate>
        <author>thomas@maurice.fr (Thomas)</author>
        <atom:modified>Sat, 29 Aug 2020 11:02:50 +0000</atom:modified>
        <guid>https://blog.thomas.maurice.fr/posts/network-namespaces-in-linux/</guid>
        <description>This post is a cheatsheet for myself in case I need to fuck around with network namespaces again.
NB: most of the commands should be ran as root.
Create a new netns 1 2 3 4  $ ip netns add testns # Check it works $ ip netns ls testns   Exec a command inside a netns 1 2 3  $ ip netns exec testns ip link show 1: lo: &amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00   Connect the namespace from the outside Choose what we want to make as a network setup We want the following:</description>
        
        <dc:creator>Thomas</dc:creator>
        <media:content url="https://blog.thomas.maurice.frimages/logos/tux.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>linux</category>
            
          
            
              <category>networking</category>
            
          
            
              <category>kernel</category>
            
          
            
              <category>namespaces</category>
            
          
        
        
          
            
              <category>linux</category>
            
          
            
              <category>networking</category>
            
          
            
              <category>kernel</category>
            
          
            
              <category>namespaces</category>
            
          
        
        
      </item>
      
      <item>
        <title>Make Your Own Travel Router With A NanoPi And Armbian</title>
        <link>https://blog.thomas.maurice.fr/posts/make-your-own-travel-router/</link>
        <pubDate>Wed, 29 Jan 2020 19:40:22 +0000</pubDate>
        <author>thomas@maurice.fr (Thomas)</author>
        <atom:modified>Wed, 29 Jan 2020 19:40:22 +0000</atom:modified>
        <guid>https://blog.thomas.maurice.fr/posts/make-your-own-travel-router/</guid>
        <description>When you travel, you may sometimes want to be able to access some resources that are present on your flat&amp;rsquo;s network, make your traffic go through a VPN or what not because you don&amp;rsquo;t trust the network you are in (wether it is a hotel/coffee shop or what not). This blogpost is going to explain how you can build a nice travel router for when you travel around, so no one steals your nudes or snoops on the sketchy p0rn you watch.</description>
        
        <dc:creator>Thomas</dc:creator>
        <media:content url="https://blog.thomas.maurice.frimages/logos/armbian.jpg" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>security</category>
            
          
            
              <category>networking</category>
            
          
            
              <category>router</category>
            
          
            
              <category>wireguard</category>
            
          
            
              <category>debian</category>
            
          
            
              <category>linux</category>
            
          
        
        
          
            
              <category>security</category>
            
          
            
              <category>debian</category>
            
          
            
              <category>networking</category>
            
          
            
              <category>linux</category>
            
          
        
        
      </item>
      
      <item>
        <title>Authenticate your services with Vault and JWTs</title>
        <link>https://blog.thomas.maurice.fr/posts/vault-jwt-authentication/</link>
        <pubDate>Fri, 17 Jan 2020 18:56:22 +0000</pubDate>
        <author>thomas@maurice.fr (Thomas)</author>
        <atom:modified>Fri, 17 Jan 2020 18:56:22 +0000</atom:modified>
        <guid>https://blog.thomas.maurice.fr/posts/vault-jwt-authentication/</guid>
        <description>Sometimes, you may want your services to be able to talk to each other in an authenticated manner, and even perform some authorization. This is not easy to do and you might have scratched your head a bunch about how to do it. In this post I&amp;rsquo;m going to show you how to do something like this using hashicorp&amp;rsquo;s Vault. At the end of this post you&amp;rsquo;ll be able to issue and validate authorization tokens to make sure your services communicate in an authenticated and secure manner.</description>
        
        <dc:creator>Thomas</dc:creator>
        <media:content url="https://blog.thomas.maurice.frimages/logos/vault.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>golang</category>
            
          
            
              <category>vault</category>
            
          
            
              <category>security</category>
            
          
        
        
          
            
              <category>golang</category>
            
          
            
              <category>vault</category>
            
          
            
              <category>security</category>
            
          
        
        
      </item>
      
      <item>
        <title>Unit Testing With Vault in Go</title>
        <link>https://blog.thomas.maurice.fr/posts/unit-testing-with-vault/</link>
        <pubDate>Sat, 11 Jan 2020 13:52:19 +0000</pubDate>
        <author>thomas@maurice.fr (Thomas)</author>
        <atom:modified>Sat, 11 Jan 2020 13:52:19 +0000</atom:modified>
        <guid>https://blog.thomas.maurice.fr/posts/unit-testing-with-vault/</guid>
        <description>Recently I&amp;rsquo;ve been dealing with Hashicorp&amp;rsquo;s Vault a lot, and I&amp;rsquo;ve had to write a bunch of code to interface with it. This post is going to be about my least favourite part of writing code: unit testing what I wrote (as everyone knows, it works on my machine, right ?).
Assumptions This article assumes that you are already familiar with what Vault is and the very basics of how to use it (get/put secrets, login and such).</description>
        
        <dc:creator>Thomas</dc:creator>
        <media:content url="https://blog.thomas.maurice.frimages/logos/vault.png" medium="image"><media:title type="html">featured image</media:title></media:content>
        
        
        
          
            
              <category>golang</category>
            
          
            
              <category>test</category>
            
          
            
              <category>vault</category>
            
          
            
              <category>security</category>
            
          
        
        
          
            
              <category>vault</category>
            
          
            
              <category>dev</category>
            
          
            
              <category>golang</category>
            
          
        
        
      </item>
      
      <item>
        <title>About</title>
        <link>https://blog.thomas.maurice.fr/about/</link>
        <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
        <author>thomas@maurice.fr (Thomas)</author>
        <atom:modified>Sat, 11 Jan 2020 00:00:00 +0000</atom:modified>
        <guid>https://blog.thomas.maurice.fr/about/</guid>
        <description>I sometimes write stuff that may be relevant to people.</description>
        
        <dc:creator>Thomas</dc:creator>
        
        
        
        
        
        
      </item>
      

    
  </channel>
</rss>