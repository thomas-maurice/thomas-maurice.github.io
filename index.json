[
{
	"uri": "http://blog.thomas.maurice.fr/",
	"title": "/var/log/tmaurice",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/dev/",
	"title": "dev",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/golang/",
	"title": "golang",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/golang/",
	"title": "golang",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/security/",
	"title": "security",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/test/",
	"title": "test",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/unit-testing-with-vault/",
	"title": "Unit Testing With Vault in Go",
	"tags": ["golang", "test", "vault", "security"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Recently I've been dealing with Hashicorp's Vault a lot, and I've had to write a bunch of code to interface with it. This post is going to be about my least favourite part of writing code: unit testing what I wrote (as everyone knows, it works on my machine, right ?).\nAssumptions This article assumes that you are already familiar with what Vault is and the very basics of how to use it (get/put secrets, login and such). It also assumes that you have some knowledge of the Go programming language.\nWhat we want Now, we have several ways of unit testing things, and usually when you talk to external systems the easiest way of doing it is by mocking the system, and writing mocks that will give you a deterministic answer to a given input. That's great and all but in my use case I wanted to be able to talk to a real Vault server, to be in more realistic testing conditions.\nFortunately, people at Hashicorp do things well, and they provide us with tooling that basically enables us to spin up a real (real!!) vault server for us to fuck around and perform all the testing we want, and I'm going to explain you how.\nSetting up the stage We will assume that we want to unit test a dummy function that will write a secret to Vault, and we want to make sure that the secret is written properly. Let's write a simple main.go file that contains our main function, as well as a putSecret function that will store our secret into Vault.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/hashicorp/vault/api\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) // Write the secret func putSecret(client *api.Client, secret map[string]interface{}, secretPath string) error { _, err := client.Logical().Write(fmt.Sprintf(\u0026#34;secret/data/%s\u0026#34;, secretPath), secret) return err } func main() { client, err := api.NewClient(api.DefaultConfig()) if err != nil { logrus.WithError(err).Fatal(\u0026#34;Could not initialise vault client\u0026#34;) } err = putSecret(client, map[string]interface{}{\u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;}, \u0026#34;baz\u0026#34;) if err != nil { logrus.WithError(err).Fatal(\u0026#34;Could not write secret\u0026#34;) } }   This is a fairly simple main.go that will just write a secret to the given path. Now how can we be sure it actually does the job ? We could just compile the program then run it against a local vault, but that just sounds tedious and annoying doesn't it ? Instead how about we use the NewTestCluster function provided by the github.com/hashicorp/vault/vault package ?\nNow let's write some tests You will need a main_test.go file that will look just like that:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  package main import ( \u0026#34;testing\u0026#34; vaulthttp \u0026#34;github.com/hashicorp/vault/http\u0026#34; \u0026#34;github.com/hashicorp/vault/vault\u0026#34; ) const ( testVaultToken = \u0026#34;token\u0026#34; // This is the root token ) func TestPutSecret(t *testing.T) { cluster := vault.NewTestCluster(t, \u0026amp;vault.CoreConfig{ DevToken: testVaultToken, }, \u0026amp;vault.TestClusterOptions{ HandlerFunc: vaulthttp.Handler, }) cluster.Start() defer cluster.Cleanup() core := cluster.Cores[0].Core vault.TestWaitActive(t, core) client := cluster.Cores[0].Client err := putSecret(client, map[string]interface{}{\u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;}, \u0026#34;secret\u0026#34;) if err != nil { t.Fatal(err) } data, err := client.Logical().Read(\u0026#34;secret/data/secret\u0026#34;) if err != nil { t.Fatal(err) } if secret, ok := data.Data[\u0026#34;foo\u0026#34;].(string); ok { if secret != \u0026#34;bar\u0026#34; { t.Fatalf(\u0026#34;Wrong secret returned: %s\u0026#34;, secret) } } else { t.Fatal(\u0026#34;Could not get secret\u0026#34;) } }   Now let's check it works\n1 2  $ go test -cover ./... ok blog.thomas.maurice.fr/vault-test\t3.625s\tcoverage: 25.0% of statements   Woo! It worked. There is some things to unpack here so let's have a look.\n First we import all the needed packages Then we start a dev cluster with a custom devToken for the unit tests. We need to clean that up afterwards so we defer the Cleanup call  Then is an interesting part. In order to talk to Vault we need a client, and since Vault starts on a random port during the tests, generates its own CA, certificates and so on to listen on HTTPS, we need to retrieve it, which is achieved by just picking a client to one of the nodes of the cluster (yes, it starts in cluster mode!).\n Then we actually use the client to test that out method actually works. Isn't it amazing ?  Pushing it further Now, another issue I've had is that I was working with approles, and I pulled my hair for a while to figure out how to make it work in my tests. It turns out that you have to explicitly tell Vault to load the plugin in order for it to work.\nI am too lazy to patch the main.go to actually use an approle, but I will demonstrate how to enable it into your vault test server, so you can use it. Note that the same pattern applies to pretty much every authentication method you may want to use.\nYou will do the following (note the additional CredentialBackends init option):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package main import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/hashicorp/vault/api\u0026#34; \u0026#34;github.com/hashicorp/vault/builtin/credential/approle\u0026#34; vaulthttp \u0026#34;github.com/hashicorp/vault/http\u0026#34; \u0026#34;github.com/hashicorp/vault/sdk/logical\u0026#34; \u0026#34;github.com/hashicorp/vault/vault\u0026#34; ) const ( testVaultToken = \u0026#34;token\u0026#34; // This is the root token ) func TestPutSecret(t *testing.T) { cluster := vault.NewTestCluster(t, \u0026amp;vault.CoreConfig{ DevToken: testVaultToken, CredentialBackends: map[string]logical.Factory{ \u0026#34;approle\u0026#34;: approle.Factory, }, }, \u0026amp;vault.TestClusterOptions{ HandlerFunc: vaulthttp.Handler, }) cluster.Start() defer cluster.Cleanup() core := cluster.Cores[0].Core vault.TestWaitActive(t, core) client := cluster.Cores[0].Client // Enable approle \terr := client.Sys().EnableAuthWithOptions(\u0026#34;approle\u0026#34;, \u0026amp;api.EnableAuthOptions{ Type: \u0026#34;approle\u0026#34;, }) if err != nil { t.Fatal(err) } // ... the rest of your unit test }   This way you can freely create an approle, and some policies why not, to use Vault as you would use it in prod:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // ..... The imports and shit func TestMyTest(t *testing.T) { // ... Vault initialization as above  // Create an approle \t_, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest\u0026#34;, map[string]interface{}{ \u0026#34;policies\u0026#34;: []string{\u0026#34;unittest\u0026#34;}, }) if err != nil { t.Fatal(err) } // Gets the role ID, that is basically the \u0026#39;username\u0026#39; used to log into vault \tres, err := client.Logical().Read(\u0026#34;auth/approle/role/unittest/role-id\u0026#34;) if err != nil { t.Fatal(err) } // Keep the roleID for later use \troleID, ok := res.Data[\u0026#34;role_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not read the approle\u0026#34;) } // Create a secretID that is basically the password for the approle  res, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest/secret-id\u0026#34;, nil) if err != nil { t.Fatal(err) } // Use thre secretID later \tsecretID, ok := res.Data[\u0026#34;secret_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not generate the secret id\u0026#34;) } // Create a broad policy to allow the approle to do whatever \terr = client.Sys().PutPolicy(\u0026#34;unittest\u0026#34;, `path \u0026#34;*\u0026#34; {capabilities = [\u0026#34;create\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;update\u0026#34;, delete] } `) if err != nil { t.Fatal(err) } }   Reusing the code If you have been paying attention to what I spent a few hours writing, something should have struck you, and that thing is there:\n1 2  $ go test -cover ./... ok blog.thomas.maurice.fr/vault-test\t3.625s\tcoverage: 25.0% of statements   Specifically the 3.625s part of it. Right now you might just be shrieking in rage and disappointment like\n Holy shit this is slow as fuck, there is now way I am ever using that this is going to slow down my CI mate\n Which is fair enough, which is why there is something you can do about it. You can create some mocks.go file that would contain all the Vault initialization code that you can reuse across multiple tests, something along the lines of:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  package main import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/hashicorp/vault/api\u0026#34; \u0026#34;github.com/hashicorp/vault/builtin/credential/approle\u0026#34; vaulthttp \u0026#34;github.com/hashicorp/vault/http\u0026#34; \u0026#34;github.com/hashicorp/vault/sdk/logical\u0026#34; \u0026#34;github.com/hashicorp/vault/vault\u0026#34; ) const ( // TestVaultToken is the Vault token used for tests \ttestVaultToken = \u0026#34;unittesttoken\u0026#34; ) type vaultTest struct { Cluster *vault.TestCluster Client *api.Client AppRoleID string AppRoleSecret string } // creates the test server func GetTestVaultServer(t *testing.T) { t.Helper() cluster := vault.NewTestCluster(t, \u0026amp;vault.CoreConfig{ DevToken: testVaultToken, CredentialBackends: map[string]logical.Factory{ \u0026#34;approle\u0026#34;: approle.Factory, }, }, \u0026amp;vault.TestClusterOptions{ HandlerFunc: vaulthttp.Handler, }) cluster.Start() core := cluster.Cores[0].Core vault.TestWaitActive(t, core) client := cluster.Cores[0].Client // Create an approle \t_, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest\u0026#34;, map[string]interface{}{ \u0026#34;policies\u0026#34;: []string{\u0026#34;unittest\u0026#34;}, }) if err != nil { t.Fatal(err) } // Gets the role ID, that is basically the \u0026#39;username\u0026#39; used to log into vault \tres, err := client.Logical().Read(\u0026#34;auth/approle/role/unittest/role-id\u0026#34;) if err != nil { t.Fatal(err) } // Keep the roleID for later use \troleID, ok := res.Data[\u0026#34;role_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not read the approle\u0026#34;) } // Create a secretID that is basically the password for the approle  res, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest/secret-id\u0026#34;, nil) if err != nil { t.Fatal(err) } // Use thre secretID later \tsecretID, ok := res.Data[\u0026#34;secret_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not generate the secret id\u0026#34;) } // Create a broad policy to allow the approle to do whatever \terr = client.Sys().PutPolicy(\u0026#34;unittest\u0026#34;, `path \u0026#34;*\u0026#34; {capabilities = [\u0026#34;create\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;update\u0026#34;, delete] } `) if err != nil { t.Fatal(err) } return vaultTest{ Cluster: cluster, Client: client, AppRoleID: roleID, AppRolESecret: secretID, } }   The only thing now is that it's on you to call testVault.Cluster.Cleanup() whenever you are done.\nFew words of warning: This assumes that the things you will do to your Vault are without any side effects to other tests, such as RO operations (retrieving tokens and certificates for exeamples) or operations that are restricted to a certain path that belongs to your unit test.\nWrapping up I hope that was helpful, happy unit testing.\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/vault/",
	"title": "vault",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/vault/",
	"title": "vault",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/about/",
	"title": "About",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "About this blog",
	"content": "I sometimes write stuff that may be relevant to people.\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]