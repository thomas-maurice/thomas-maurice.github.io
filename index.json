[
{
	"uri": "http://blog.thomas.maurice.fr/",
	"title": "/var/log/tmaurice",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/vault-jwt-authentication/",
	"title": "Authenticate your services with Vault and JWTs",
	"tags": ["golang", "vault", "security"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Sometimes, you may want your services to be able to talk to each other in an authenticated manner, and even perform some authorization. This is not easy to do and you might have scratched your head a bunch about how to do it. In this post I'm going to show you how to do something like this using hashicorp's Vault. At the end of this post you'll be able to issue and validate authorization tokens to make sure your services communicate in an authenticated and secure manner.\nWhat are JWTs ? JWT, or JSON Web Tokens, are tokens that are signed by a central authority that encapsulate authorization information. This website can help debugging your tokens.\nA JWT is comprised of 3 parts\n Header Payload Signature  The header gives you a bunch of infos about the algorithm used, the key id used to sign the token and so on. The payload is the actual encoded auth data that you care about and the signature is used to validate the token.\nSetup Vault We are going to demonstrate that with a dev vault, so first start a vault server in a separate terminal.\n1  $ vault server -dev-root-token-id=token -dev   In another terminal\n1 2  export VAULT_ADDR=http://localhost:8200 export VAULT_TOKEN=token   Create a Vault policy We will need to create a policy to allow the account (that we will create right after) to perform some basic operations on Vault. For the purpose of this article we are going to create a read only policy on the whole Vault. You obviously do not want to do that in an actual production environment.\n1 2  echo \u0026#34;path \\\u0026#34;*\\\u0026#34; {capabilities = [\\\u0026#34;read\\\u0026#34;]}\u0026#34; | vault policy write readonly - Success! Uploaded policy: readonly   Create the OIDC issuer To create the OIDC issuer, do\n1  $ vault write identity/issuer/config issuer=http://localhost:8200   This will be used to populate the issuer field of your tokens.\nYou will need then to create a key to sign your tokens:\n1 2  $ vault write identity/oidc/key/key algorithm=ES256 allowed_client_ids=\u0026#39;*\u0026#39; Success! Data written to: identity/oidc/key/key   Alright now we had a key that will sign our tokens. Note that in a real production environment you will need to have a key per environment (dev/staging/prod and so on) and will need to individually allow client ID (which we talk about later) to be signed by your key.\nYou then need to create something called a role in Vault. Which will map to the app you want to authenticate against. In this example we will assume that our app is called demo, you will have to create it as follows (so it is signed with the key created above):\n1 2  $ vault write identity/oidc/role/demo name=demo key=key Success! Data written to: identity/oidc/role/demo   Good! No we need to create a user to authenticate.\nCreate the AppRole An AppRole is a Vault authentication backend. You can see it as something similar to a username/password authentication, but intended for services instead of actual human users.\nEnable the approle authentication backend:\n1 2  $ vault auth enable approle Success! Enabled approle auth method at: approle/   Now create the actual approle, it will be called demo-approle:\n1 2  $ vault write auth/approle/role/demo-approle role_name=demo-approle policies=readonly Success! Data written to: auth/approle/role/demo-approle   Then you will need to get two pieces of information, the roleid and the secretid for the approle. These are the equivalent of the username and the password to authenticate yourself.\n1 2 3 4  $ secret_id=$(vault write -force -format=json auth/approle/role/demo-approle/secret-id | jq -r .data.secret_id) $ role_id=$(vault read -format=json auth/approle/role/demo-approle/role-id | jq -r .data.role_id) $ echo $role_id $secret_id ca9f0470-8d1f-4464-2635-25f02b9407d7 f91a7c31-dc06-2b24-20fd-e9f5867c32a8   Your values will be different.\nCreate the entity and map it to the AppRole Now that we have created the approle, we need to map it to an internal Vault entity, you need to do that because several entities can be mapped to various authentication backends, like userpass or if you use something like Google or what not. So first, create the entity and save it for later:\n1 2 3  entity_id=$(vault write -format=json identity/entity name=demo |jq .data.id -r) $ echo $entity_id c957656f-0872-766c-3517-83b787672f84   Now you finally need to create an entity alias to make the link between the entity and the approle authentication backend (that is tedious I know but bear with me i swear it is worth it). Retrieve the accessor, which is the internal Vault reference to your approle authentication backend:\n1 2 3  $ accessor=$(vault auth list -format=json | grep \u0026#39;auth_approle\u0026#39; | tr -d \u0026#34; \u0026#34; | tr -d , | cut -d \u0026#34;:\u0026#34; -f 2 | tr -d \\\u0026#34;) $ echo $accessor auth_approle_91098819   Now finally (y e s f i n a l l y) create the alias:\n1 2 3 4 5  $ vault write identity/entity-alias name=demo canonical_id=$entity_id mount_accessor=$accessor Key Value --- ----- canonical_id c957656f-0872-766c-3517-83b787672f84 id a2d067d6-229b-6580-d714-35a01ba62864   Aight. Everything is setup now.\nLog in as the AppRole Now all you need to do is to log into Vault using the approle, then issue a token:\n1 2 3 4  $ token=$(vault write -format=json auth/approle/login role_id=$role_id secret_id=$secret_id | jq -r .auth.client_token) $Â export VAULT_TOKEN=$token $ echo $token s.ohsNR1DIo6sVr8gG8hsRsk1Y   You are now logged into Vault as your approle ! Check it by running:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  vault token lookup Key Value --- ----- accessor Tc6riT70kLnepiW3CC0rEkBj creation_time 1579287446 creation_ttl 768h display_name approle entity_id f1be740b-8b4f-4369-a019-bc6ef3f8e963 expire_time 2020-02-18T18:57:26.707866969Z explicit_max_ttl 0s id s.ohsNR1DIo6sVr8gG8hsRsk1Y issue_time 2020-01-17T18:57:26.707866723Z meta map[role_name:demo-approle] num_uses 0 orphan true path auth/approle/login policies [default readonly] renewable true ttl 767h58m57s type service   Issue a token Finally you can issue a token:\n1 2 3 4 5 6  $ vault read identity/oidc/token/demo Key Value --- ----- client_id waqwjTM57B7ANxhw7CketPy1WJ token eyJhbGciOiJFUzI1NiIsImtpZCI6Ijk2MmNiZTk3LWYzY2EtMTVjMy0wNDJkLTYxZTQzMWMxOTRlMCJ9.eyJhdWQiOiJ3YXF3alRNNTdCN0FOeGh3N0NrZXRQeTFXSiIsImV4cCI6MTU3OTM3NDAwOCwiaWF0IjoxNTc5Mjg3NjA4LCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjgyMDAvdjEvaWRlbnRpdHkvb2lkYyIsIm5hbWVzcGFjZSI6InJvb3QiLCJzdWIiOiJmMWJlNzQwYi04YjRmLTQzNjktYTAxOS1iYzZlZjNmOGU5NjMifQ.OSVQHaIS9kgzdckNgsneDorR7BzE9i6JajOsBKIoByGuSMd5MTyPcu4nwv9GGAgips_mMk9dYTzckCGDcR8gXQ ttl 24h   You can now use this token to identify to a service !\nLet's unpack the token a bit using the debugger. The headers read\n1 2 3 4  { \u0026#34;alg\u0026#34;: \u0026#34;ES256\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;962cbe97-f3ca-15c3-042d-61e431c194e0\u0026#34; }   The is not much about it, it specifies the signature algorithm used and the key id used to sign the token, more on that later.\nThe body of the token reads the following:\n1 2 3 4 5 6 7 8  { \u0026#34;aud\u0026#34;: \u0026#34;waqwjTM57B7ANxhw7CketPy1WJ\u0026#34;, \u0026#34;exp\u0026#34;: 1579374008, \u0026#34;iat\u0026#34;: 1579287608, \u0026#34;iss\u0026#34;: \u0026#34;http://localhost:8200/v1/identity/oidc\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;f1be740b-8b4f-4369-a019-bc6ef3f8e963\u0026#34; }   Here you have a bunch of infos about the identity of the token bearer:\n exp is the expiration time of the token iat is the issuance time iss is the issuer aud is the intended audience of the token, namely the demo OIDC role you created above sub is the subject of the token, namely the identity of the bearer. If you pay attention, this is the same UUID as the one referenced in the entity_id field of the vault token lookup command.  You can now identify who's token you are looking at !\nIf you use Vault, you can also add more custom fields, such as group membership and other arbitrary things, more info on that here.\nVerifying the tokens Now you need to be able to verify the tokens. I will not expand on how to do the authorization, that's your logic, and your problem, same for the expiration and issuer verification. However you need to be able to verify the signature of the token to establish that the token:\n Comes from whom it says it comes from Is signed by a key owned by whom it says it comes from  Vault exposes an unauthenticated endpoint that allows you to retrieve the public part of the signing keys used for the tokens, which you can access the following way\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ curl localhost:8200/v1/identity/oidc/.well-known/keys| jq . { \u0026#34;keys\u0026#34;: [ { \u0026#34;use\u0026#34;: \u0026#34;sig\u0026#34;, \u0026#34;kty\u0026#34;: \u0026#34;EC\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;962cbe97-f3ca-15c3-042d-61e431c194e0\u0026#34;, \u0026#34;crv\u0026#34;: \u0026#34;P-256\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;ES256\u0026#34;, \u0026#34;x\u0026#34;: \u0026#34;Ui3tAkTBb-dudDOyCyIQCfNz_1xG7ByoyJJwrEhBUFw\u0026#34;, \u0026#34;y\u0026#34;: \u0026#34;mj68rHTcy121ojJCjHJ88uRCgNF0CF90nPfHGu-YnwI\u0026#34; } ] }   If you pay attention and fluently speak UUID, you will obviously notice that 962cbe97-f3ca-15c3-042d-61e431c194e0 is the kid present in the header of the token we have previously issued.\nThis way you can verify that the signature is valid. Note that Vault implements the openID discovery protocol which can give you access to even more information.\nWrap up I hope that will be useful to you to use Vault as an OIDC provider for your services ! :)\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/golang/",
	"title": "golang",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/golang/",
	"title": "golang",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/security/",
	"title": "security",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/security/",
	"title": "security",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/vault/",
	"title": "vault",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/vault/",
	"title": "vault",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/dev/",
	"title": "dev",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/test/",
	"title": "test",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/unit-testing-with-vault/",
	"title": "Unit Testing With Vault in Go",
	"tags": ["golang", "test", "vault", "security"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Recently I've been dealing with Hashicorp's Vault a lot, and I've had to write a bunch of code to interface with it. This post is going to be about my least favourite part of writing code: unit testing what I wrote (as everyone knows, it works on my machine, right ?).\nAssumptions This article assumes that you are already familiar with what Vault is and the very basics of how to use it (get/put secrets, login and such). It also assumes that you have some knowledge of the Go programming language.\nWhat we want Now, we have several ways of unit testing things, and usually when you talk to external systems the easiest way of doing it is by mocking the system, and writing mocks that will give you a deterministic answer to a given input. That's great and all but in my use case I wanted to be able to talk to a real Vault server, to be in more realistic testing conditions.\nFortunately, people at Hashicorp do things well, and they provide us with tooling that basically enables us to spin up a real (real!!) vault server for us to fuck around and perform all the testing we want, and I'm going to explain you how.\nSetting up the stage We will assume that we want to unit test a dummy function that will write a secret to Vault, and we want to make sure that the secret is written properly. Let's write a simple main.go file that contains our main function, as well as a putSecret function that will store our secret into Vault.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/hashicorp/vault/api\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) // Write the secret func putSecret(client *api.Client, secret map[string]interface{}, secretPath string) error { _, err := client.Logical().Write(fmt.Sprintf(\u0026#34;secret/data/%s\u0026#34;, secretPath), secret) return err } func main() { client, err := api.NewClient(api.DefaultConfig()) if err != nil { logrus.WithError(err).Fatal(\u0026#34;Could not initialise vault client\u0026#34;) } err = putSecret(client, map[string]interface{}{\u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;}, \u0026#34;baz\u0026#34;) if err != nil { logrus.WithError(err).Fatal(\u0026#34;Could not write secret\u0026#34;) } }   This is a fairly simple main.go that will just write a secret to the given path. Now how can we be sure it actually does the job ? We could just compile the program then run it against a local vault, but that just sounds tedious and annoying doesn't it ? Instead how about we use the NewTestCluster function provided by the github.com/hashicorp/vault/vault package ?\nNow let's write some tests You will need a main_test.go file that will look just like that:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  package main import ( \u0026#34;testing\u0026#34; vaulthttp \u0026#34;github.com/hashicorp/vault/http\u0026#34; \u0026#34;github.com/hashicorp/vault/vault\u0026#34; ) const ( testVaultToken = \u0026#34;token\u0026#34; // This is the root token ) func TestPutSecret(t *testing.T) { cluster := vault.NewTestCluster(t, \u0026amp;vault.CoreConfig{ DevToken: testVaultToken, }, \u0026amp;vault.TestClusterOptions{ HandlerFunc: vaulthttp.Handler, }) cluster.Start() defer cluster.Cleanup() core := cluster.Cores[0].Core vault.TestWaitActive(t, core) client := cluster.Cores[0].Client err := putSecret(client, map[string]interface{}{\u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;}, \u0026#34;secret\u0026#34;) if err != nil { t.Fatal(err) } data, err := client.Logical().Read(\u0026#34;secret/data/secret\u0026#34;) if err != nil { t.Fatal(err) } if secret, ok := data.Data[\u0026#34;foo\u0026#34;].(string); ok { if secret != \u0026#34;bar\u0026#34; { t.Fatalf(\u0026#34;Wrong secret returned: %s\u0026#34;, secret) } } else { t.Fatal(\u0026#34;Could not get secret\u0026#34;) } }   Now let's check it is working\n1 2  $ go test -cover ./... ok blog.thomas.maurice.fr/vault-test 3.625s coverage: 25.0% of statements   Woo! It worked. There is some things to unpack here so let's have a look.\n First we import all the needed packages Then we start a dev cluster with a custom devToken for the unit tests. We need to clean that up afterwards so we defer the Cleanup call  Then is an interesting part. In order to talk to Vault we need a client, and since Vault starts on a random port during the tests, generates its own CA, certificates and so on to listen on HTTPS, we need to retrieve it, which is achieved by just picking a client to one of the nodes of the cluster (yes, it starts in cluster mode!).\n Then we actually use the client to test that our method actually works. Isn't it amazing ?  Pushing it further Now, another issue I've had is that I was working with approles, and I pulled my hair for a while trying to figure out how to make it work in my tests. It turns out that you have to explicitly tell Vault to load the plugin in order for it to work.\nI am too lazy to patch the main.go to actually use an approle, but I will demonstrate how to enable it into your vault test server, so you can use it. Note that the same pattern applies to pretty much every authentication method you may want to use.\nYou will do the following (note the additional CredentialBackends init option):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package main import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/hashicorp/vault/api\u0026#34; \u0026#34;github.com/hashicorp/vault/builtin/credential/approle\u0026#34; vaulthttp \u0026#34;github.com/hashicorp/vault/http\u0026#34; \u0026#34;github.com/hashicorp/vault/sdk/logical\u0026#34; \u0026#34;github.com/hashicorp/vault/vault\u0026#34; ) const ( testVaultToken = \u0026#34;token\u0026#34; // This is the root token ) func TestPutSecret(t *testing.T) { cluster := vault.NewTestCluster(t, \u0026amp;vault.CoreConfig{ DevToken: testVaultToken, CredentialBackends: map[string]logical.Factory{ \u0026#34;approle\u0026#34;: approle.Factory, }, }, \u0026amp;vault.TestClusterOptions{ HandlerFunc: vaulthttp.Handler, }) cluster.Start() defer cluster.Cleanup() core := cluster.Cores[0].Core vault.TestWaitActive(t, core) client := cluster.Cores[0].Client // Enable approle  err := client.Sys().EnableAuthWithOptions(\u0026#34;approle\u0026#34;, \u0026amp;api.EnableAuthOptions{ Type: \u0026#34;approle\u0026#34;, }) if err != nil { t.Fatal(err) } // ... the rest of your unit test }   In case you are wondering, the core object above refers to a Vault node of the test cluster.\nThis way you can freely create an approle, and some policies (why not ?!), to use Vault as you would use it in prod:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // ..... The imports and shit func TestMyTest(t *testing.T) { // ... Vault initialization as above  // Create an approle  _, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest\u0026#34;, map[string]interface{}{ \u0026#34;policies\u0026#34;: []string{\u0026#34;unittest\u0026#34;}, }) if err != nil { t.Fatal(err) } // Gets the role ID, that is basically the \u0026#39;username\u0026#39; used to log into vault  res, err := client.Logical().Read(\u0026#34;auth/approle/role/unittest/role-id\u0026#34;) if err != nil { t.Fatal(err) } // Keep the roleID for later use  roleID, ok := res.Data[\u0026#34;role_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not read the approle\u0026#34;) } // Create a secretID that is basically the password for the approle  res, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest/secret-id\u0026#34;, nil) if err != nil { t.Fatal(err) } // Use thre secretID later  secretID, ok := res.Data[\u0026#34;secret_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not generate the secret id\u0026#34;) } // Create a broad policy to allow the approle to do whatever  err = client.Sys().PutPolicy(\u0026#34;unittest\u0026#34;, `path \u0026#34;*\u0026#34; {capabilities = [\u0026#34;create\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;update\u0026#34;, delete] } `) if err != nil { t.Fatal(err) } }   Reusing the code If you have been paying attention to what I spent a few hours writing, something should have struck you, and that thing is there:\n1 2  $ go test -cover ./... ok blog.thomas.maurice.fr/vault-test 3.625s coverage: 25.0% of statements   Specifically the 3.625s part of it. Right now you might just be shrieking in rage and disappointment like\n Holy shit this is slow as fuck, there is now way I am ever using that this is going to slow down my CI mate\n Which is fair enough, which is why there is something you can do about it. You can create some mocks.go file that would contain all the Vault initialization code that you can reuse across multiple tests, something along the lines of:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  package main import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/hashicorp/vault/api\u0026#34; \u0026#34;github.com/hashicorp/vault/builtin/credential/approle\u0026#34; vaulthttp \u0026#34;github.com/hashicorp/vault/http\u0026#34; \u0026#34;github.com/hashicorp/vault/sdk/logical\u0026#34; \u0026#34;github.com/hashicorp/vault/vault\u0026#34; ) const ( // TestVaultToken is the Vault token used for tests  testVaultToken = \u0026#34;unittesttoken\u0026#34; ) type vaultTest struct { Cluster *vault.TestCluster Client *api.Client AppRoleID string AppRoleSecret string } // creates the test server func GetTestVaultServer(t *testing.T) vaultTest { t.Helper() cluster := vault.NewTestCluster(t, \u0026amp;vault.CoreConfig{ DevToken: testVaultToken, CredentialBackends: map[string]logical.Factory{ \u0026#34;approle\u0026#34;: approle.Factory, }, }, \u0026amp;vault.TestClusterOptions{ HandlerFunc: vaulthttp.Handler, }) cluster.Start() core := cluster.Cores[0].Core vault.TestWaitActive(t, core) client := cluster.Cores[0].Client // Create an approle  _, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest\u0026#34;, map[string]interface{}{ \u0026#34;policies\u0026#34;: []string{\u0026#34;unittest\u0026#34;}, }) if err != nil { t.Fatal(err) } // Gets the role ID, that is basically the \u0026#39;username\u0026#39; used to log into vault  res, err := client.Logical().Read(\u0026#34;auth/approle/role/unittest/role-id\u0026#34;) if err != nil { t.Fatal(err) } // Keep the roleID for later use  roleID, ok := res.Data[\u0026#34;role_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not read the approle\u0026#34;) } // Create a secretID that is basically the password for the approle  res, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest/secret-id\u0026#34;, nil) if err != nil { t.Fatal(err) } // Use thre secretID later  secretID, ok := res.Data[\u0026#34;secret_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not generate the secret id\u0026#34;) } // Create a broad policy to allow the approle to do whatever  err = client.Sys().PutPolicy(\u0026#34;unittest\u0026#34;, `path \u0026#34;*\u0026#34; {capabilities = [\u0026#34;create\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;update\u0026#34;, delete] } `) if err != nil { t.Fatal(err) } return vaultTest{ Cluster: cluster, Client: client, AppRoleID: roleID, AppRolESecret: secretID, } }   The only thing now is that it's on you to call testVault.Cluster.Cleanup() whenever you are done.\nFew words of warning: This assumes that the things you will do to your Vault are without any side effects to other tests, such as RO operations (retrieving tokens and certificates for exeamples) or operations that are restricted to a certain path that belongs to your unit test.\nWrapping up I hope that was helpful, happy unit testing.\nCredits Big thanks to daenney and kdevroede for the review !\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/about/",
	"title": "About",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "About this blog",
	"content": "I sometimes write stuff that may be relevant to people.\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]