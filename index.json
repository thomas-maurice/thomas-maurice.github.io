[
{
	"uri": "http://blog.thomas.maurice.fr/",
	"title": "/var/log/tmaurice",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/kernel/",
	"title": "kernel",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/kernel/",
	"title": "kernel",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/linux/",
	"title": "linux",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/linux/",
	"title": "linux",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/namespaces/",
	"title": "namespaces",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/namespaces/",
	"title": "namespaces",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/network-namespaces-in-linux/",
	"title": "Network namespaces in Linux",
	"tags": ["linux", "networking", "kernel", "namespaces"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "This post is a cheatsheet for myself in case I need to fuck around with network namespaces again.\nNB: most of the commands should be ran as root.\nCreate a new netns 1 2 3 4  $ ip netns add testns # Check it works $ ip netns ls testns   Exec a command inside a netns 1 2 3  $ ip netns exec testns ip link show 1: lo: \u0026lt;LOOPBACK\u0026gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00   Connect the namespace from the outside Choose what we want to make as a network setup We want the following:\n The netns interface will have the 10.69.69.2/24 address It should be able to talk to the outside It will do so via a bridge on the host with the 10.69.69.1/24 address Traffic to the outside will me SNATed  Setup the outside of the network namespace First let\u0026rsquo;s create the network interfaces we need, we want to have a bridge and a veth pair.\n1 2 3  $ ip link add br-netns type bridge # Create a veth pair with one of the interfaces in out netns $ ip link add veth0 type veth peer name veth1 netns testns   Now set veth0\u0026rsquo;s master as the bridge\n1  $ ip link set master br-netns dev veth0   Setup the bridge address\n1  $ ip address add 10.69.69.1/24 dev br-netns   Make the bridge and veth up\n1 2  $ ip link set up dev br-netns $ ip link set up dev veth0   Finally setup iptables\n1 2 3  $ iptables -I FORWARD -i br-netns -o enx0050b6f2bc54 -j ACCEPT $ iptables -I FORWARD -o br-netns -i enx0050b6f2bc54 -j ACCEPT $ iptables -t nat -I POSTROUTING -s 10.69.69.0/24 -j MASQUERADE   Setup the inside of the network namespace Let us enter the namespace\n1  $ ip netns exec testns bash   Configure the interface\u0026rsquo;s address and turn it on\n1 2  $ ip address add 10.69.69.2/24 dev veth1 $ ip link set up dev veth1   Set the default route\n1  $ ip route add default via 10.69.69.1   Check it works 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  $ ping 8.8.8.8 -c 10 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=115 time=14.4 ms 64 bytes from 8.8.8.8: icmp_seq=2 ttl=115 time=12.9 ms 64 bytes from 8.8.8.8: icmp_seq=3 ttl=115 time=10.0 ms 64 bytes from 8.8.8.8: icmp_seq=4 ttl=115 time=13.1 ms 64 bytes from 8.8.8.8: icmp_seq=5 ttl=115 time=10.2 ms 64 bytes from 8.8.8.8: icmp_seq=6 ttl=115 time=10.3 ms 64 bytes from 8.8.8.8: icmp_seq=7 ttl=115 time=27.4 ms 64 bytes from 8.8.8.8: icmp_seq=8 ttl=115 time=9.77 ms 64 bytes from 8.8.8.8: icmp_seq=9 ttl=115 time=11.2 ms 64 bytes from 8.8.8.8: icmp_seq=10 ttl=115 time=11.2 ms --- 8.8.8.8 ping statistics --- 10 packets transmitted, 10 received, 0% packet loss, time 9012ms rtt min/avg/max/mdev = 9.774/13.055/27.416/5.009 ms   Tada!\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/networking/",
	"title": "networking",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/networking/",
	"title": "networking",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/debian/",
	"title": "debian",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/debian/",
	"title": "debian",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/make-your-own-travel-router/",
	"title": "Make Your Own Travel Router With A NanoPi And Armbian",
	"tags": ["security", "networking", "router", "wireguard", "debian", "linux"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "When you travel, you may sometimes want to be able to access some resources that are present on your flat\u0026rsquo;s network, make your traffic go through a VPN or what not because you don\u0026rsquo;t trust the network you are in (wether it is a hotel/coffee shop or what not). This blogpost is going to explain how you can build a nice travel router for when you travel around, so no one steals your nudes or snoops on the sketchy p0rn you watch.\nWhat we are going to achieve I\u0026rsquo;ll show you how you can build a small armbian-based router that enables you you:\n Connect to some WAN Have a local LAN with a custom DHCP range Have a second LAN (potentially accessible over WiFi) that routes all your traffic through a wireguard VPN tunnel Have a local DNS over TLS resolver so you avoid leaking DNS queries  Bill of materials For this project, I purchased a £60 Nano Pi R1 off Amazon. You can find a cheaper one (10 quids less) if you are ready to drop from 1G to 512M of RAM, and even cheaper if you drop the metal casing. But I took the beefier version and the metal casing because having a nice packaging is always nice.\nI then used an extra WiFi dongle I used on my old Raspberry Pies, which is probably worth 10ish quids.\nSlap an OS on it ! Initially I wanted to setup the router using OpenWRT, but as usual I didn\u0026rsquo;t check the hardware\u0026rsquo;s compatibility before buying it and OpenWRT is not supported yet, sucks to be me but oh well, I\u0026rsquo;ll use an other operating system there, Armbian. This is basically a Debian fork targetted at embedded systems, that embeds a recent kernel and a bunch of cool things such as built in Wireguard support.\nGet the OS there (you can either use Debian Buster or Ubuntu Bionic at the time of writing, I went with Buster, but Bionic should be pretty similar), burn it on an SD card and insert it on the device.\nLog into the box Just SSH on the box using ssh root@\u0026lt;ip\u0026gt; using the password 1234. You will be prompted to setup a new password, then do whatever you want to feel comfortable on the box, like installing tmux, vim, zsh if you are into that.\nInitial settings Predictible interface names I\u0026rsquo;m not sure about you, but I really hate systemd style interface names and I want my eth* and wlan* names: To do that add the following line to the /boot/armbianEnv.txt file:\nextraargs=net.ifnames=0 Disable IPv6 I have no need for IPv6, I\u0026rsquo;ll just disable it, add to /etc/sysctl.conf:\nnet.ipv6.conf.all.disable_ipv6=1 net.ipv6.conf.default.disable_ipv6=1 Install a few packets 1 2 3 4  $ apt-get install -y \\  bridge-utils \\  wireguard-tools \\  tcpdump   Reboot 1  $ reboot   Setting up the network interfaces So if you look at what you have right now, you should see the following\n1 2 3 4 5 6 7 8 9 10 11 12 13  root swagmachine ~ # ip l 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: dummy0: \u0026lt;BROADCAST,NOARP\u0026gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether f6:5e:56:31:05:2b brd ff:ff:ff:ff:ff:ff 3: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000 link/ether 12:81:4e:91:08:48 brd ff:ff:ff:ff:ff:ff 4: eth1: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc pfifo_fast master lan0 state DOWN mode DEFAULT group default qlen 1000 link/ether 8a:d7:e4:18:a5:bd brd ff:ff:ff:ff:ff:ff 5: wlan0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq master vpn0 state UP mode DEFAULT group default qlen 1000 link/ether 00:0f:55:a8:2d:52 brd ff:ff:ff:ff:ff:ff 6: wlan1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast master lan0 state UP mode DORMANT group default qlen 1000 link/ether a2:a9:5e:07:b5:5b brd ff:ff:ff:ff:ff:ff   Remember the following:\n eth0 is the WAN interface, the one you connect to the upstream network eth1 is the LAN interface, the one you can connect to with your laptop for instance wlan0 is the internal wifi interface, we will use it as a VPN only access point wlan1 is the USB wifi dongle, we will use it to create a local network without VPN  Setting up the wireguard tunnel I won\u0026rsquo;t expand on how to setup a wireguard tunnel here, I refet you to this excellent article by brouberol\nAt the end of it you should end up with a wg0 interface. You can create as many as you want, if you want to add a wg1 interface that would allow you to connect to your home network for instance.\nHere for reference is my own /etc/wireguard/wg0.conf\n[Interface] PrivateKey = [REDACTED] ListenPort = 5555 SaveConfig = false Address = 192.168.11.10/32 Table = 42 [Peer] PublicKey = [REDACTED] AllowedIPs = 0.0.0.0/0 Endpoint = [REDACTED]:5555 Note that the Table = 42 parameter is super important since otherwise Wireguard is going to interfere with your other routing tables and rules, which you do not want. The 42 number is arbitrary you can pick whatever you want as long as it matches the routing table number you assign to the vpn routing table that you will create in the next section.\nStart the interface now\n1  $ systemctl start wg-quick@wg0   Create a custom routing table We need a custom routing table for the VPN only network, this will allow us to make sure that the traffic on this network is routed accordingly to this table, to avoid it going out unencrypted through eth0 and leaking to potential curious eyes. Alter the /etc/iproute2/rt_tables file as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13  $ cat /etc/iproute2/rt_tables # # reserved values # 255 local 254 main 253 default 42 vpn 0 unspec # # local # #1 inr.ruhep   The 42 vpn means that we create a routing table with id 42 and assign it the name vpn. The ID can be anything between 1 and 252, and the name can be anything.\nSetting up the bridges We are going to create the following bridges:\n vpn0, which we will use to route the VPN traffic lan0, which we will use to route the local LAN traffic  1 2 3 4 5 6 7 8 9 10 11 12  $ cat /etc/network/interfaces.d/lan0 auto lan0 iface lan0 inet static address 10.69.0.1 netmask 255.255.255.0 bridge_ports eth1 # Optionally you can force the lan0 trafic to be routed through the main routing table # this can be useful if you have a setup with several routing tables depending on the # input interface. In this setup it is optional but I\u0026#39;ll leave it for reference #post-up /sbin/ip rule add iif lan0 lookup main priority 999 #down /sbin/ip rule del iif lan0 lookup main priority 999 || true   Here we setup lan0 as the master for eth1, and assign the range 10.69.0.1/24. Next up the vpn0 interface:\n1 2 3 4 5 6 7 8 9 10 11 12  $ cat /etc/network/interfaces.d/vpn0 auto vpn0 iface vpn0 inet static address 10.69.1.1 netmask 255.255.255.0 bridge_ports none pre-up ip link add $IFACE type bridge post-up /sbin/ip rule add iif vpn0 lookup vpn priority 1000 post-up /sbin/ip rule add iif vpn0 blackhole priority 1001 down /sbin/ip route del default dev wg0 table vpn || true down /sbin/ip rule del iif vpn0 lookup vpn priority 1000 || true down /sbin/ip rule del iif vpn0 blackhole priority 1001 || true   There is a bunch of stuff to unpack here. We create the vpn0 interface as a bridge (with the pre-up command). Then we assign the 10.69.1.1/24 range to the interface.\nThen we have a bunch of post-up and down commands, which are invoked respectively when the interface is brought up and down.\n pre-up ip link add $IFACE type bridge creates the interface post-up /sbin/ip route add default dev wg0 table vpn sets the wg0 interface as the default interface for the vpn routing table we created above post-up /sbin/ip rule add iif vpn0 lookup vpn priority 1000 inserts the routing table in the routing evaluation list with a high priority (higher than the standard one) for all the packets that come from the vpn0 interface. post-up /sbin/ip rule add iif vpn0 blackhole priority 1001 same as above, except we nullroute the packets. This makes sure that if the packet do not match any routes from the routing table it gets dropped instead of leaked.  You may now bring the interfaces up\n1 2  # ifup vpn0 # ifup lan0   Setup the wifi accesspoints Install hostapd if it is not already present\n1  apt-get install hostapd   And now create the two networks, the LAN:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $ cat /etc/hostapd-lan.conf interface=wlan1 hw_mode=g ieee80211n=1 ieee80211d=1 channel=10 bridge=lan0 country_code=GB wmm_enabled=1 ssid=travel wireless wpa=2 wpa_passphrase=somepassword wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP auth_algs=1   And the VPN\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  $ cat /etc/hostapd-vpn.conf interface=wlan0 hw_mode=g channel=5 bridge=vpn0 driver=nl80211 ieee80211n=1 ht_capab=[DSSS_CK-40][HT20+] country_code=GB ieee80211d=1 ctrl_interface=/var/run/hostapd ctrl_interface_group=0 logger_syslog=0 logger_syslog_level=0 wmm_enabled=1 ssid=vpn network wpa=2 wpa_passphrase=someotherpassword wpa_key_mgmt=WPA-PSK wpa_pairwise=TKIP rsn_pairwise=CCMP auth_algs=1   Note the bridge= configuration directives that instruct hostapd to setup the interfaces with vpn0 and lan0 as masters.\nThen edit the default hostapd arguments to make sure these 2 config files are loaded:\n1 2 3 4 5 6 7 8 9 10 11  # cat /etc/default/hostapd # Defaults for hostapd initscript # # See /usr/share/doc/hostapd/README.Debian for information about alternative # methods of managing hostapd. # # Uncomment and set DAEMON_CONF to the absolute path of a hostapd configuration # file and hostapd will be started during system boot. An example configuration # file can be found at /usr/share/doc/hostapd/examples/hostapd.conf.gz # DAEMON_CONF=\u0026#34;/etc/hostapd-lan.conf /etc/hostapd-vpn.conf\u0026#34;   Then restart the service\n1  # systemctl restart hostapd   You should now see your 2 SSID announced.\nSetup DHCP We use dnsmasq for DHCP, it should be installed by default. Setup the following configuration file and restart the service:\n1 2 3 4 5 6 7 8 9 10 11 12  cat /etc/dnsmasq.conf interface=vpn0 listen-address=10.69.0.1,10.69.1.1 server=6,10.69.0.1 domain-needed bogus-priv dhcp-range=interface:vpn0,10.69.1.50,10.69.1.150,12h dhcp-range=interface:lan0,10.69.0.50,10.69.0.150,12h dhcp-option=interface:vpn0,3,10.69.1.1 dhcp-option=interface:lan0,3,10.69.0.1 dhcp-option=interface:vpn0,6,10.69.1.1 dhcp-option=interface:lan0,6,10.69.0.1   This sets up the IP ranges for the two interfaces and forces them to use the router as the resolver.\nSetup DNS Setup unbound We will now setup unbound as a DNS resolver, update the config and restart the service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  include: \u0026#34;/etc/unbound/unbound.conf.d/*.conf\u0026#34; server: verbosity: 1 interface: 10.69.1.1 interface: 10.69.0.1 interface: 127.0.0.1 access-control: 0.0.0.0/0 allow do-ip4: yes do-ip6: no do-tcp: yes logfile: /var/log/unbound/unbound.log hide-identity: yes hide-version: yes harden-glue: yes use-caps-for-id: yes do-not-query-localhost: no forward-zone: name: \u0026#34;.\u0026#34; forward-addr: 1.1.1.1@853 forward-addr: 9.9.9.9@853 forward-ssl-upstream: yes   This sets up unbound to forward the DNS queries to cloudflare and quad9 DNS servers, using TLS so you would not leak the queries.\nNuke systemd-resolved It has the annoying habbit to change /etc/resolve.conf, just edit the file to make it look like\n1  nameserver 127.0.0.1   Then\n1  # chattr +i /etc/resolv.conf   This will ensure that no one can modify the file.\nSetup iptables You now need to setup the iptables rules to allow everything to work, edit the /etc/iptables.ipv4.nat file (this will only work on armbian):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  *filter -A INPUT -i lo -j ACCEPT -m comment --comment \u0026#34;Allow local traffic\u0026#34; -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -m comment --comment \u0026#34;Allow established connexions\u0026#34; -A INPUT -p icmp -j ACCEPT -m comment --comment \u0026#34;Allow pings\u0026#34; -A INPUT -p tcp --dport 22 -j ACCEPT -m comment --comment \u0026#34;Allow SSH\u0026#34; -A INPUT -p tcp --dport 53 -j ACCEPT -m comment --comment \u0026#34;Allow DNS\u0026#34; -A INPUT -p udp --dport 68 -j ACCEPT -m comment --comment \u0026#34;Allow DHCP\u0026#34; -A INPUT -p udp --dport 67 -j ACCEPT -m comment --comment \u0026#34;Allow DHCP\u0026#34; # Forward to eth0 -A FORWARD -i lan0 -o eth0 -j ACCEPT -A FORWARD -o lan0 -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT # Forward to wg0 -A FORWARD -i vpn0 -o wg0 -j ACCEPT -A FORWARD -o vpn0 -i wg0 -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -i lan0 -j ACCEPT -A INPUT -i vpn0 -j ACCEPT COMMIT # NAT rules *nat -A POSTROUTING -s 10.69.0.0/24 -o eth0 -j MASQUERADE -m comment --comment \u0026#34;LAN masquerade\u0026#34; -A POSTROUTING -s 10.69.1.0/24 -o wg0 -j MASQUERADE -m comment --comment \u0026#34;VPN masquerade\u0026#34; COMMIT *raw :PREROUTING ACCEPT :OUTPUT ACCEPT COMMIT *nat :PREROUTING ACCEPT :POSTROUTING ACCEPT :OUTPUT ACCEPT COMMIT *mangle :PREROUTING ACCEPT :INPUT ACCEPT :FORWARD ACCEPT :OUTPUT ACCEPT :POSTROUTING ACCEPT COMMIT *filter :INPUT ACCEPT :FORWARD ACCEPT :OUTPUT ACCEPT COMMIT # Default policies *filter -A INPUT -j DROP -A FORWARD -j DROP COMMIT   Finish it ! Now reboot, and you should have a functional travel router that allows you to secure your communication with a VPN wireless network !\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/router/",
	"title": "router",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/security/",
	"title": "security",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/security/",
	"title": "security",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/wireguard/",
	"title": "wireguard",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/vault-jwt-authentication/",
	"title": "Authenticate your services with Vault and JWTs",
	"tags": ["golang", "vault", "security"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Sometimes, you may want your services to be able to talk to each other in an authenticated manner, and even perform some authorization. This is not easy to do and you might have scratched your head a bunch about how to do it. In this post I\u0026rsquo;m going to show you how to do something like this using hashicorp\u0026rsquo;s Vault. At the end of this post you\u0026rsquo;ll be able to issue and validate authorization tokens to make sure your services communicate in an authenticated and secure manner.\nWhat are JWTs ? JWT, or JSON Web Tokens, are tokens that are signed by a central authority that encapsulate authorization information. This website can help debugging your tokens.\nA JWT is comprised of 3 parts\n Header Payload Signature  The header gives you a bunch of infos about the algorithm used, the key id used to sign the token and so on. The payload is the actual encoded auth data that you care about and the signature is used to validate the token.\nSetup Vault We are going to demonstrate that with a dev vault, so first start a vault server in a separate terminal.\n1  $ vault server -dev-root-token-id=token -dev   In another terminal\n1 2  export VAULT_ADDR=http://localhost:8200 export VAULT_TOKEN=token   Create a Vault policy We will need to create a policy to allow the account (that we will create right after) to perform some basic operations on Vault. For the purpose of this article we are going to create a read only policy on the whole Vault. You obviously do not want to do that in an actual production environment.\n1 2  echo \u0026#34;path \\\u0026#34;*\\\u0026#34; {capabilities = [\\\u0026#34;read\\\u0026#34;]}\u0026#34; | vault policy write readonly - Success! Uploaded policy: readonly   Create the OIDC issuer To create the OIDC issuer, do\n1  $ vault write identity/issuer/config issuer=http://localhost:8200   This will be used to populate the issuer field of your tokens.\nYou will need then to create a key to sign your tokens:\n1 2  $ vault write identity/oidc/key/key algorithm=ES256 allowed_client_ids=\u0026#39;*\u0026#39; Success! Data written to: identity/oidc/key/key   Alright now we had a key that will sign our tokens. Note that in a real production environment you will need to have a key per environment (dev/staging/prod and so on) and will need to individually allow client ID (which we talk about later) to be signed by your key.\nYou then need to create something called a role in Vault. Which will map to the app you want to authenticate against. In this example we will assume that our app is called demo, you will have to create it as follows (so it is signed with the key created above):\n1 2  $ vault write identity/oidc/role/demo name=demo key=key Success! Data written to: identity/oidc/role/demo   Good! No we need to create a user to authenticate.\nCreate the AppRole An AppRole is a Vault authentication backend. You can see it as something similar to a username/password authentication, but intended for services instead of actual human users.\nEnable the approle authentication backend:\n1 2  $ vault auth enable approle Success! Enabled approle auth method at: approle/   Now create the actual approle, it will be called demo-approle:\n1 2  $ vault write auth/approle/role/demo-approle role_name=demo-approle policies=readonly Success! Data written to: auth/approle/role/demo-approle   Then you will need to get two pieces of information, the roleid and the secretid for the approle. These are the equivalent of the username and the password to authenticate yourself.\n1 2 3 4  $ secret_id=$(vault write -force -format=json auth/approle/role/demo-approle/secret-id | jq -r .data.secret_id) $ role_id=$(vault read -format=json auth/approle/role/demo-approle/role-id | jq -r .data.role_id) $ echo $role_id $secret_id ca9f0470-8d1f-4464-2635-25f02b9407d7 f91a7c31-dc06-2b24-20fd-e9f5867c32a8   Your values will be different.\nCreate the entity and map it to the AppRole Now that we have created the approle, we need to map it to an internal Vault entity, you need to do that because several entities can be mapped to various authentication backends, like userpass or if you use something like Google or what not. So first, create the entity and save it for later:\n1 2 3  entity_id=$(vault write -format=json identity/entity name=demo |jq .data.id -r) $ echo $entity_id c957656f-0872-766c-3517-83b787672f84   Now you finally need to create an entity alias to make the link between the entity and the approle authentication backend (that is tedious I know but bear with me i swear it is worth it). Retrieve the accessor, which is the internal Vault reference to your approle authentication backend:\n1 2 3  $ accessor=$(vault auth list -format=json | grep \u0026#39;auth_approle\u0026#39; | tr -d \u0026#34; \u0026#34; | tr -d , | cut -d \u0026#34;:\u0026#34; -f 2 | tr -d \\\u0026#34;) $ echo $accessor auth_approle_91098819   Now finally (y e s f i n a l l y) create the alias:\n1 2 3 4 5  $ vault write identity/entity-alias name=demo canonical_id=$entity_id mount_accessor=$accessor Key Value --- ----- canonical_id c957656f-0872-766c-3517-83b787672f84 id a2d067d6-229b-6580-d714-35a01ba62864   Aight. Everything is setup now.\nLog in as the AppRole Now all you need to do is to log into Vault using the approle, then issue a token:\n1 2 3 4  $ token=$(vault write -format=json auth/approle/login role_id=$role_id secret_id=$secret_id | jq -r .auth.client_token) $ export VAULT_TOKEN=$token $ echo $token s.ohsNR1DIo6sVr8gG8hsRsk1Y   You are now logged into Vault as your approle ! Check it by running:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  vault token lookup Key Value --- ----- accessor Tc6riT70kLnepiW3CC0rEkBj creation_time 1579287446 creation_ttl 768h display_name approle entity_id f1be740b-8b4f-4369-a019-bc6ef3f8e963 expire_time 2020-02-18T18:57:26.707866969Z explicit_max_ttl 0s id s.ohsNR1DIo6sVr8gG8hsRsk1Y issue_time 2020-01-17T18:57:26.707866723Z meta map[role_name:demo-approle] num_uses 0 orphan true path auth/approle/login policies [default readonly] renewable true ttl 767h58m57s type service   Issue a token Finally you can issue a token:\n1 2 3 4 5 6  $ vault read identity/oidc/token/demo Key Value --- ----- client_id waqwjTM57B7ANxhw7CketPy1WJ token eyJhbGciOiJFUzI1NiIsImtpZCI6Ijk2MmNiZTk3LWYzY2EtMTVjMy0wNDJkLTYxZTQzMWMxOTRlMCJ9.eyJhdWQiOiJ3YXF3alRNNTdCN0FOeGh3N0NrZXRQeTFXSiIsImV4cCI6MTU3OTM3NDAwOCwiaWF0IjoxNTc5Mjg3NjA4LCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjgyMDAvdjEvaWRlbnRpdHkvb2lkYyIsIm5hbWVzcGFjZSI6InJvb3QiLCJzdWIiOiJmMWJlNzQwYi04YjRmLTQzNjktYTAxOS1iYzZlZjNmOGU5NjMifQ.OSVQHaIS9kgzdckNgsneDorR7BzE9i6JajOsBKIoByGuSMd5MTyPcu4nwv9GGAgips_mMk9dYTzckCGDcR8gXQ ttl 24h   You can now use this token to identify to a service !\nLet\u0026rsquo;s unpack the token a bit using the debugger. The headers read\n1 2 3 4  { \u0026#34;alg\u0026#34;: \u0026#34;ES256\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;962cbe97-f3ca-15c3-042d-61e431c194e0\u0026#34; }   The is not much about it, it specifies the signature algorithm used and the key id used to sign the token, more on that later.\nThe body of the token reads the following:\n1 2 3 4 5 6 7 8  { \u0026#34;aud\u0026#34;: \u0026#34;waqwjTM57B7ANxhw7CketPy1WJ\u0026#34;, \u0026#34;exp\u0026#34;: 1579374008, \u0026#34;iat\u0026#34;: 1579287608, \u0026#34;iss\u0026#34;: \u0026#34;http://localhost:8200/v1/identity/oidc\u0026#34;, \u0026#34;namespace\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;f1be740b-8b4f-4369-a019-bc6ef3f8e963\u0026#34; }   Here you have a bunch of infos about the identity of the token bearer:\n exp is the expiration time of the token iat is the issuance time iss is the issuer aud is the intended audience of the token, namely the demo OIDC role you created above sub is the subject of the token, namely the identity of the bearer. If you pay attention, this is the same UUID as the one referenced in the entity_id field of the vault token lookup command.  You can now identify who\u0026rsquo;s token you are looking at !\nIf you use Vault, you can also add more custom fields, such as group membership and other arbitrary things, more info on that here.\nVerifying the tokens Now you need to be able to verify the tokens. I will not expand on how to do the authorization, that\u0026rsquo;s your logic, and your problem, same for the expiration and issuer verification. However you need to be able to verify the signature of the token to establish that the token:\n Comes from whom it says it comes from Is signed by a key owned by whom it says it comes from  Vault exposes an unauthenticated endpoint that allows you to retrieve the public part of the signing keys used for the tokens, which you can access the following way\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  $ curl localhost:8200/v1/identity/oidc/.well-known/keys| jq . { \u0026#34;keys\u0026#34;: [ { \u0026#34;use\u0026#34;: \u0026#34;sig\u0026#34;, \u0026#34;kty\u0026#34;: \u0026#34;EC\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;962cbe97-f3ca-15c3-042d-61e431c194e0\u0026#34;, \u0026#34;crv\u0026#34;: \u0026#34;P-256\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;ES256\u0026#34;, \u0026#34;x\u0026#34;: \u0026#34;Ui3tAkTBb-dudDOyCyIQCfNz_1xG7ByoyJJwrEhBUFw\u0026#34;, \u0026#34;y\u0026#34;: \u0026#34;mj68rHTcy121ojJCjHJ88uRCgNF0CF90nPfHGu-YnwI\u0026#34; } ] }   If you pay attention and fluently speak UUID, you will obviously notice that 962cbe97-f3ca-15c3-042d-61e431c194e0 is the kid present in the header of the token we have previously issued.\nThis way you can verify that the signature is valid. Note that Vault implements the openID discovery protocol which can give you access to even more information.\nWrap up I hope that will be useful to you to use Vault as an OIDC provider for your services ! :)\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/golang/",
	"title": "golang",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/golang/",
	"title": "golang",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/vault/",
	"title": "vault",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/vault/",
	"title": "vault",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/categories/dev/",
	"title": "dev",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/tags/test/",
	"title": "test",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.thomas.maurice.fr/posts/unit-testing-with-vault/",
	"title": "Unit Testing With Vault in Go",
	"tags": ["golang", "test", "vault", "security"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Recently I\u0026rsquo;ve been dealing with Hashicorp\u0026rsquo;s Vault a lot, and I\u0026rsquo;ve had to write a bunch of code to interface with it. This post is going to be about my least favourite part of writing code: unit testing what I wrote (as everyone knows, it works on my machine, right ?).\nAssumptions This article assumes that you are already familiar with what Vault is and the very basics of how to use it (get/put secrets, login and such). It also assumes that you have some knowledge of the Go programming language.\nWhat we want Now, we have several ways of unit testing things, and usually when you talk to external systems the easiest way of doing it is by mocking the system, and writing mocks that will give you a deterministic answer to a given input. That\u0026rsquo;s great and all but in my use case I wanted to be able to talk to a real Vault server, to be in more realistic testing conditions.\nFortunately, people at Hashicorp do things well, and they provide us with tooling that basically enables us to spin up a real (real!!) vault server for us to fuck around and perform all the testing we want, and I\u0026rsquo;m going to explain you how.\nSetting up the stage We will assume that we want to unit test a dummy function that will write a secret to Vault, and we want to make sure that the secret is written properly. Let\u0026rsquo;s write a simple main.go file that contains our main function, as well as a putSecret function that will store our secret into Vault.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/hashicorp/vault/api\u0026#34; \u0026#34;github.com/sirupsen/logrus\u0026#34; ) // Write the secret func putSecret(client *api.Client, secret map[string]interface{}, secretPath string) error { _, err := client.Logical().Write(fmt.Sprintf(\u0026#34;secret/data/%s\u0026#34;, secretPath), secret) return err } func main() { client, err := api.NewClient(api.DefaultConfig()) if err != nil { logrus.WithError(err).Fatal(\u0026#34;Could not initialise vault client\u0026#34;) } err = putSecret(client, map[string]interface{}{\u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;}, \u0026#34;baz\u0026#34;) if err != nil { logrus.WithError(err).Fatal(\u0026#34;Could not write secret\u0026#34;) } }   This is a fairly simple main.go that will just write a secret to the given path. Now how can we be sure it actually does the job ? We could just compile the program then run it against a local vault, but that just sounds tedious and annoying doesn\u0026rsquo;t it ? Instead how about we use the NewTestCluster function provided by the github.com/hashicorp/vault/vault package ?\nNow let\u0026rsquo;s write some tests You will need a main_test.go file that will look just like that:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  package main import ( \u0026#34;testing\u0026#34; vaulthttp \u0026#34;github.com/hashicorp/vault/http\u0026#34; \u0026#34;github.com/hashicorp/vault/vault\u0026#34; ) const ( testVaultToken = \u0026#34;token\u0026#34; // This is the root token ) func TestPutSecret(t *testing.T) { cluster := vault.NewTestCluster(t, \u0026amp;vault.CoreConfig{ DevToken: testVaultToken, }, \u0026amp;vault.TestClusterOptions{ HandlerFunc: vaulthttp.Handler, }) cluster.Start() defer cluster.Cleanup() core := cluster.Cores[0].Core vault.TestWaitActive(t, core) client := cluster.Cores[0].Client err := putSecret(client, map[string]interface{}{\u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;}, \u0026#34;secret\u0026#34;) if err != nil { t.Fatal(err) } data, err := client.Logical().Read(\u0026#34;secret/data/secret\u0026#34;) if err != nil { t.Fatal(err) } if secret, ok := data.Data[\u0026#34;foo\u0026#34;].(string); ok { if secret != \u0026#34;bar\u0026#34; { t.Fatalf(\u0026#34;Wrong secret returned: %s\u0026#34;, secret) } } else { t.Fatal(\u0026#34;Could not get secret\u0026#34;) } }   Now let\u0026rsquo;s check it is working\n1 2  $ go test -cover ./... ok blog.thomas.maurice.fr/vault-test 3.625s coverage: 25.0% of statements   Woo! It worked. There is some things to unpack here so let\u0026rsquo;s have a look.\n First we import all the needed packages Then we start a dev cluster with a custom devToken for the unit tests. We need to clean that up afterwards so we defer the Cleanup call  Then is an interesting part. In order to talk to Vault we need a client, and since Vault starts on a random port during the tests, generates its own CA, certificates and so on to listen on HTTPS, we need to retrieve it, which is achieved by just picking a client to one of the nodes of the cluster (yes, it starts in cluster mode!).\n Then we actually use the client to test that our method actually works. Isn\u0026rsquo;t it amazing ?  Pushing it further Now, another issue I\u0026rsquo;ve had is that I was working with approles, and I pulled my hair for a while trying to figure out how to make it work in my tests. It turns out that you have to explicitly tell Vault to load the plugin in order for it to work.\nI am too lazy to patch the main.go to actually use an approle, but I will demonstrate how to enable it into your vault test server, so you can use it. Note that the same pattern applies to pretty much every authentication method you may want to use.\nYou will do the following (note the additional CredentialBackends init option):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package main import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/hashicorp/vault/api\u0026#34; \u0026#34;github.com/hashicorp/vault/builtin/credential/approle\u0026#34; vaulthttp \u0026#34;github.com/hashicorp/vault/http\u0026#34; \u0026#34;github.com/hashicorp/vault/sdk/logical\u0026#34; \u0026#34;github.com/hashicorp/vault/vault\u0026#34; ) const ( testVaultToken = \u0026#34;token\u0026#34; // This is the root token ) func TestPutSecret(t *testing.T) { cluster := vault.NewTestCluster(t, \u0026amp;vault.CoreConfig{ DevToken: testVaultToken, CredentialBackends: map[string]logical.Factory{ \u0026#34;approle\u0026#34;: approle.Factory, }, }, \u0026amp;vault.TestClusterOptions{ HandlerFunc: vaulthttp.Handler, }) cluster.Start() defer cluster.Cleanup() core := cluster.Cores[0].Core vault.TestWaitActive(t, core) client := cluster.Cores[0].Client // Enable approle  err := client.Sys().EnableAuthWithOptions(\u0026#34;approle\u0026#34;, \u0026amp;api.EnableAuthOptions{ Type: \u0026#34;approle\u0026#34;, }) if err != nil { t.Fatal(err) } // ... the rest of your unit test }   In case you are wondering, the core object above refers to a Vault node of the test cluster.\nThis way you can freely create an approle, and some policies (why not ?!), to use Vault as you would use it in prod:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  // ..... The imports and shit func TestMyTest(t *testing.T) { // ... Vault initialization as above  // Create an approle  _, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest\u0026#34;, map[string]interface{}{ \u0026#34;policies\u0026#34;: []string{\u0026#34;unittest\u0026#34;}, }) if err != nil { t.Fatal(err) } // Gets the role ID, that is basically the \u0026#39;username\u0026#39; used to log into vault  res, err := client.Logical().Read(\u0026#34;auth/approle/role/unittest/role-id\u0026#34;) if err != nil { t.Fatal(err) } // Keep the roleID for later use  roleID, ok := res.Data[\u0026#34;role_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not read the approle\u0026#34;) } // Create a secretID that is basically the password for the approle  res, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest/secret-id\u0026#34;, nil) if err != nil { t.Fatal(err) } // Use thre secretID later  secretID, ok := res.Data[\u0026#34;secret_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not generate the secret id\u0026#34;) } // Create a broad policy to allow the approle to do whatever  err = client.Sys().PutPolicy(\u0026#34;unittest\u0026#34;, ` path \u0026#34;*\u0026#34; { capabilities = [\u0026#34;create\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;update\u0026#34;, delete] } `) if err != nil { t.Fatal(err) } }   Reusing the code If you have been paying attention to what I spent a few hours writing, something should have struck you, and that thing is there:\n1 2  $ go test -cover ./... ok blog.thomas.maurice.fr/vault-test 3.625s coverage: 25.0% of statements   Specifically the 3.625s part of it. Right now you might just be shrieking in rage and disappointment like\n Holy shit this is slow as fuck, there is now way I am ever using that this is going to slow down my CI mate\n Which is fair enough, which is why there is something you can do about it. You can create some mocks.go file that would contain all the Vault initialization code that you can reuse across multiple tests, something along the lines of:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  package main import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/hashicorp/vault/api\u0026#34; \u0026#34;github.com/hashicorp/vault/builtin/credential/approle\u0026#34; vaulthttp \u0026#34;github.com/hashicorp/vault/http\u0026#34; \u0026#34;github.com/hashicorp/vault/sdk/logical\u0026#34; \u0026#34;github.com/hashicorp/vault/vault\u0026#34; ) const ( // TestVaultToken is the Vault token used for tests  testVaultToken = \u0026#34;unittesttoken\u0026#34; ) type vaultTest struct { Cluster *vault.TestCluster Client *api.Client AppRoleID string AppRoleSecret string } // creates the test server func GetTestVaultServer(t *testing.T) vaultTest { t.Helper() cluster := vault.NewTestCluster(t, \u0026amp;vault.CoreConfig{ DevToken: testVaultToken, CredentialBackends: map[string]logical.Factory{ \u0026#34;approle\u0026#34;: approle.Factory, }, }, \u0026amp;vault.TestClusterOptions{ HandlerFunc: vaulthttp.Handler, }) cluster.Start() core := cluster.Cores[0].Core vault.TestWaitActive(t, core) client := cluster.Cores[0].Client // Create an approle  _, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest\u0026#34;, map[string]interface{}{ \u0026#34;policies\u0026#34;: []string{\u0026#34;unittest\u0026#34;}, }) if err != nil { t.Fatal(err) } // Gets the role ID, that is basically the \u0026#39;username\u0026#39; used to log into vault  res, err := client.Logical().Read(\u0026#34;auth/approle/role/unittest/role-id\u0026#34;) if err != nil { t.Fatal(err) } // Keep the roleID for later use  roleID, ok := res.Data[\u0026#34;role_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not read the approle\u0026#34;) } // Create a secretID that is basically the password for the approle  res, err = client.Logical().Write(\u0026#34;auth/approle/role/unittest/secret-id\u0026#34;, nil) if err != nil { t.Fatal(err) } // Use thre secretID later  secretID, ok := res.Data[\u0026#34;secret_id\u0026#34;].(string) if !ok { t.Fatal(\u0026#34;Could not generate the secret id\u0026#34;) } // Create a broad policy to allow the approle to do whatever  err = client.Sys().PutPolicy(\u0026#34;unittest\u0026#34;, ` path \u0026#34;*\u0026#34; { capabilities = [\u0026#34;create\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;list\u0026#34;, \u0026#34;update\u0026#34;, delete] } `) if err != nil { t.Fatal(err) } return vaultTest{ Cluster: cluster, Client: client, AppRoleID: roleID, AppRolESecret: secretID, } }   The only thing now is that it\u0026rsquo;s on you to call testVault.Cluster.Cleanup() whenever you are done.\nFew words of warning: This assumes that the things you will do to your Vault are without any side effects to other tests, such as RO operations (retrieving tokens and certificates for exeamples) or operations that are restricted to a certain path that belongs to your unit test.\nWrapping up I hope that was helpful, happy unit testing.\nCredits Big thanks to daenney and kdevroede for the review !\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/about/",
	"title": "About",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "About this blog",
	"content": "I sometimes write stuff that may be relevant to people.\n"
},
{
	"uri": "http://blog.thomas.maurice.fr/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]